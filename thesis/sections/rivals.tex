\documentclass[../main.tex]{subfiles}

\begin{document}

\section{WASM Rivals}

WASM is not the only PAB used in the blockchain space, other technologies use different solutions involving different protocols and algorithms. Examples are Ethereum with the custom PAB executed by the EVM (Ethereum Virtual Machine) or Solana that used eBPF to implement SmartContracts.

\subsection{EVM}

Ethereum Virtual Machine code ~\cite{buterin2014next} is one of the first PAB used in blockchain. It does not implements all the features of a perfect PAB, since it was created to be an optimized blockchain's bytecode on the Ethereum Virtual Machine, which is the glue that makes code executable on every machine.

The EVM is the main building block of the Ethereum technology. It executes stack based code and manages all the memory and access to the storage, following therefore the same principles of an embedder for wasm with many features tied to the measurement of the computation on-chain, called gas.

\subsection{eBPF}

\subsubsection{What is eBPF}

eBPF stands for 'Extended Berkeley Packet Filter', but the current extent of eBPF makes the acronym an incorrect representation of it.

Linux brought eBPF into the kernel, enabling sandboxed programs to run inside a privileged context (OS level). For lot of different reasons keeping the kernel updated was a difficult task and eBPF intended to solve this problem.

The main issue was: how can a new feature be developed once and be added to the Linux kernel, keeping in mind that running arbitrary code developed by whoever in the kernel is absolutely not safe and that the same code must be able to run on different architectures?

The solution was to have the operating system grant efficiency ans security through a JIT compiler and a verification engine used to run eBPF program. To achieve that every kernel contains an eBPF VM able to check the termination and the security of the program.

Main points of eBPF to make the verification process possible are:~\cite{ebpf}
\begin{enumerate}
  \item There are no functions in the code, there is only an unique blanket of code
  \item there is limited control flow
  \item Loops need to be statically defined, they are unrolled at compile time
  \item The execution can't pass twice on the same code
\end{enumerate}

\subsubsection{Solana eBPF}

Not every program can compile to eBPF but a distributed systems need to execute arbitrary code and limitations as strict as those posed by eBPF are too strong. To overcome these issues Solana~\cite{yakovenko2018solana} forked the eBPF backend of LLVM and removed lots of constraint, keeping the finality guarantee by the standard gas metering.~\cite{ebpf-contracts}

%LB>> define LLVM

Solana also created a new virtual machine for eBPF, \href{https://github.com/qmonnet/rbpf}, which is able to check, compile and execute the forked eBPF code on the blockchain.

eBPF is a perfect PAB for some use cases, as the linux kernel, but it does not seem to be a good fit for blockchains, due to the its limitations:
\begin{enumerate}
  \item limited control flow
  \item limited loops
  \item 64 bit usage, which implies lots of checks on the memory access
  \item 8 bytes instructions, which are too long
\end{enumerate}

\subsection{RISC-V}

RISC-V is a new instruction-set architecture (ISA)~\cite{risc-v-spec}, even if it is an actual bytecode for a specific hardware. While it seems not to match what has been described so far as a PAB, there are running experiments that validate it as a valid option as a PAB.

There are several reasons why RISC-V could be a good PAB even if it was designed to be an ISA:
\begin{description}[style=nextline]
  \item[Real ISA suitable for direct native hardware implementation]
        RISC-V is designed to be executed on real hardware, no assumption is made on the hardware itself, the only requirement being to respect all the constraints of the specifications.
        
%LB>> following sentence unclear
        The ISA is developed following general machine patterns with something completely new but still very related to other machines making really easy the translation.

  \item[RISC]
        The name RISC stands for Reduced Instruction Set Computer. As a matter of fact, the specifications are then very small and simple, making possible the creation of a base executor in really few lines of code.
  \item[Completely open ISA]
        RISC-V is an open standard, which makes possible for everyone to know the behavior and possibly create custom hardware to execute it.
  \item[ISA separated into a small base integer ISA]
        RISC-V is divided into smaller ISA, each one can work alone and can also be composed to achieve different functionalities. One of the most important division is the 32-bit and 64-bit address space division, which makes possible the creation of a sandboxed environment in ad easy and effective way.
\end{description}

\subsubsection{RISC-V for SmartConctract}

One experiment~\cite{polkavm-forum} to port RISC-V in the Polkadot ecosystem as a language for SmartConctract is hosted here: \href{https://github.com/koute/polkavm-experiment}{polkavm-experiment}.

The spec are so easy that creating an interpreter required only one day and the JIT only two days more. Those two executors were then tested against other PABs with different executors, each one executed the same code: a NES emulator written in Rust and the interpretation was how close to 60 FPS the code can get.

%LB>> I don't understand "a NES emulator written in Rust and the interpretation was how close to 60 FPS the code can get"

A comparison of the performance of the different implementations gave the following results:

\begin{itemize}
    \item wasmi: 108ms/frame (~9.2 FPS)
    \item wasmer singlepass: 10.8ms/frame (~92 FPS)
    \item wasmer cranelift: 4.8ms/frame (~208 FPS)
    \item wasmtime: 5.3ms/frame (~188 FPS)
    \item solana\_rbpf (interpreted): 6930ms/frame (~0.14 FPS)
    \item solana\_rbpf (JIT): ~625ms/frame (~1.6 FPS)
    \item RISC-V interpreter: ~800ms/frame (1.25 FPS)
    \item RISC-V JIT: ~25ms/frame (~40 FPS)
\end{itemize}

As you can see the simplicity of RISC-V allowed the creation of a JIT compiler faster than many competing compilers already already in use.

An important difference with respect to  eBPF are dedicated instructions for host functions (syscall) and the support in rustc and LLVM. One of the main constraint is the number of registers (32) used in RISC-V, while most architectures use 16 registers. The compiler or interpreter then must properly manage those extra required registers.

\end{document}
