\documentclass[../main.tex]{subfiles}

\begin{document}

\section{Platform-Agnostic Bytecode}
\subsection{Definition}

A Platform-Agnostic Bytecode (PAB), from now on will be defined as a bytecode that follows those two main principles:
\begin{itemize}
    \item Turing Completeness
    \item Support for tooling that makes it executable on every machine
\end{itemize}

A bytecode like this ideally is designed to be executed on a virtual machine that follows general patterns. This design should make easier the compilation to another real machine's bytecode. Examples of real architectures with specified bytecode are AMD and Intel with x86 or ARM with aarch64. % TODO: check this last sentence

\subsection{Execution}

PABs require multiple phases of compilation. The first one is encountered when you want to compile your High-Level language to the PAB using a Cross-Compiler. Once you have the PAB code, you should be able to run it on every machine using another compiler that will create the final executable code.

Re-compiling is not the only way to execute a PAB, another common solution is to implement a Virtual Machine (VM) able to run arbitrary PAB code interpreting it.

\subsection{Key features}

Every bytecode, ideally, can become a PAB if tools to make it runnable to different machine exist. There are however some metrics to define which one is better than others; example of metrics are:

\begin{description}[style=nextline]
  \item[Hardware Independence]
        A bytecode if tightly related to specific hardware can't become a PAB because translations to different hardware would be impossible. A weakly coupled bytecode though can become PAB if the coupling to a specific hardware is negligible and requires some minor adaptations to run on different hardware is required. A bytecode completely hardware independent, that does not make any specific assumption on the hardware on which will be running on, is the better one.
  \item[Sandboxing]
        The machine used to execute the PAB is defined as \textit{embedder}. The embedder will execute arbitrary code, possibly malicious.  A sandboxed environment is the typical solution to overcome any security problem. The execution in a different environment makes almost impossible to compromise the embedder from the PAB code. Implementing a proper sandboxed environment is embedder dependent but a PAB can be more or less suitable for this feature.

        \begin{figure}[h]
          \centering
          \includegraphics[width=0.4\linewidth]{sandboxed_env.png}
          \caption{Sandboxing graphic example}
          \label{fig:Sandboxing graphic example}
        \end{figure}

  \item[Efficiency]
        The efficiency of a PAB has several facets, it could refer to:

        \begin{itemize}
          \item the efficiency of compiling High-Level Language to the PAB
          \item the efficiency of the execution of the PAB. In this case it could refer to the compilation to the final bytecode and the subsequent execution, the interpretation or more complex solutions
        \end{itemize}

        Generally the first is not really related to the PAB, but more on the used tools (examples gcc, rustc, etc.). The execution efficiency is the real deal: how fast a PAB can be executed on a machine is crucial.
  \item[Tool Simplicity]
        The easiness of compiling a High-Level language and  executing the PAB is very important to make it usable by every one.
  \item[Support as Compilation Target]
        Writing bytecode by hand is something really rare and done only in specific cases. Every compiled language has a compiler to make this, and is very important for a PAB to support the compilation from as many languages as possible.
\end{description}

\subsection{Current usage}

PAB are already widely used. A few examples are:

\begin{itemize}
  \item
        The Java Virtual Machine (JVM) is one of the first that made the portability of the code one of the main concern of the language
  \item
        % Is the cite useful here?
        Linux brought eBPF~\cite{ebpf}, explained in one of the following chapters, into the kernel, enabling arbitrary programs to be executed in a privileged context (OS level)
  \item
        LLVM IR is the LLVM~\cite{LLVM} assembly language, it provides type safety, low-level operations, flexibility, and the capability of representing ‘all’ high-level languages cleanly. It is the common code representation used throughout all phases of the LLVM compilation strategy.
  \item
        WebAssembly~\cite{wasm-core-spec} is a safe, portable, low-level code format designed for efficient execution and compact representation.
\end{itemize}

\subsection{PAB in blockchains}

Blockchains are distributed systems that need to agree on the execution of arbitrary code performed on different machines. The goal of each machine is to produce blocks that are connected with hashes creating a block chain, machines that take part in the block production are also called nodes. Nodes are part of a trust-less network, nodes can't rely on the blocks produce by other nodes, they must verify in someway the correctness of those blocks by themselves.
% MAYBE is worth to explain what a blockchain is??

Let's simplify and define the block production algorithm as a function that takes an arbitrary input and produce and arbitrary output, input and output are then bundled together to produce a block. Little caveat, though, is that each input depends also on all the previous produced blocks.

If Block A is the first block it contains A.input and A.output (A.input is a special input that does not depend on the previous block because A is the genesis block). A node then produces block B on top of block A while another node produces block C on top of A, now new nodes can be added on top of A, B, or C. A new node that just joins the network must decide where to append a new block, Figure~\ref{fig:block_prod}, this question is extremely difficult and will not be entirely answered in the next chapters. You will understand only how to answer a sub-section of the question: on top of which block the node is secure to not build a new one?

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\linewidth]{block_prod.png}
  \caption{Block Production Example}
  \label{fig:block_prod}
\end{figure}

PABs are the answer to this question. The main point of having input and output contained in the blocks, inside a trust-less network, is to let the nodes re-execute blocks to make sure other nodes behaved correctly.

The function that gives the output must return the same result regardless of the node and the node's architecture to make everyone agree on the correctness of new blocks, that will be called `execution determinism`.

The new node in the network is able to start from A.input, compute A.output, make sure the block known is correct and do the same for the other blocks. If the node has an output that differs from what reported in the block then is secure that the block is wrong and should not be used as base for a new block.

\

PABs are the most suitable solution to implement the function just explained, they can represent any type of logic (first principle of a PAB) and be executed on every machine (second principle), the only missing feature requested by blockchains is execution determinism, that can be also be addressed by PABs as you will see in the next chapters.


\end{document}
